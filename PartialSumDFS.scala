//レッスン2-5
//部分和問題を解くために、再帰関数を使った深さ優先探索アルゴリズム
/* 
  問題：
  整数n個で作られた数列aがあります。(= n個の整数を要素として持つSeq)
  数列aの中の整数からいくつかを選び、その和が整数kとなる組み合わせが存在するかどうかを示してください。
  また、存在する場合には、その組み合わせも表示してください。
  なお、n,kはともに整数で、-10億<=n<=10億 -10億<=k<=10億 とします。
*/

/* 
  一回の呼び出しの中で、
  数列の一番目の要素を「足す場合」と「足さない場合」の2つの再帰呼び出しを行うことで、
  最終的に全てのパターンを網羅する実装方法。

  この再帰呼び出しの手続きは、最初にn回再起呼び出しをしている。
  今回のように、パターンを樹形図で表したときのツリーを深く掘って、
  最初のパターンを最初に判定するような探索方法を、「深さ優先探索」と呼ぶ
*/

object partialSumDFS extends App {
  val a = Seq(1, 10, 49, 3, 8, 13, 7, 23, 60, -500, 42, 599, 45, -23, 1, 10, 49, 3 , 8, 13)
  val n = a.length
  val k = 444

  //部分和を求める関数で、再帰的に呼び出される
  /* 
    引数(引数の型)
      index(Int)...数列を走査する際のインデックス
      partial(Seq)...ここまでに足すことが決定した整数を要素として含むSeq
    戻り値
      結果が出たかどうかの真偽値
      結果が出た際の整数の一覧を、Seqで表示
  */
  def isMatchAndResult(index: Int, partial: Seq[Int]): (Boolean, Seq[Int]) = {

    //再帰呼び出しの終了条件と終了時の処理
    if(index == n){
      //答えはマッチしたかどうかの真偽値と結果を納めたSeqが、タプルで返される
      //マッチしていたら、trueと和がマッチした整数群を格納したSeq
      //マッチしていなければ、falseと空のSeq
      return if(partial.sum == k) (true, partial) else(false, Seq())
    }

    /* 再帰呼び出し */
    /* 現在のインデックスの整数を結果に「加えない」のか「加える」かで二度再帰呼び出しを行う */


    //現在のインデックスの整数は、結果に加えない場合の再帰呼び出し
    //現在のインデックスに1を加えた値と、直前までの結果を収めたSeqを引数として、再帰呼び出し
    //再帰呼び出しの結果、答えがマッチしたら、return句を使ってこの関数の処理を終了させて結果を返す
    val (isMatchNotAdd, resultNotAdd) = isMatchAndResult(index + 1, partial)
    if(isMatchNotAdd) return (isMatchNotAdd, resultNotAdd)

    //現在のインデックスの整数を、結果に加える場合の再帰呼び出し
    //現在のインデックスに1を加えた値と、直前までの結果に現在のインデックスの整数を追加したSeqを引数として、再帰呼び出し
    isMatchAndResult(index + 1, partial :+ a(index))
  }
  
  /*
    定数の宣言と、その定数に代入する形で関数を呼び出す
    val isMatch
    val result 
    ↓ 分割代入で、定数宣言を1行に書き換え(* 分割代入では、すでに中身が存在するvar変数への再代入はできない)
  */
  val (isMatch, result) = isMatchAndResult(0, Seq())

  if(isMatch) println(s"Yes ${result}") else println("No")
}